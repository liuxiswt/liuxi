1. Java 内存区域 
线程私有的：
程序计数器(字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，
如：顺序执行、选择、循环、异常处理不会出现 OutOfMemoryError 的内存区域)
虚拟机栈(栈内存)主要存放了编译器可知的各种数据类型(8种基础)和对象引用。Java 栈中保存的主要内容是栈帧，return和抛异常导致栈帧被弹出
StackOverFlowError： 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，
就抛出 StackOverFlowError 错误。
OutOfMemoryError： 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出 OutOfMemoryError 错误。
本地方法栈：则为虚拟机使用到的 Native 方法服务。本地方法被执行的时候，在本地方法栈也会创建一个栈帧，
用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。
线程共享的：
堆(存放对象实例以及数组)Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor
方法区(也叫永久代)存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码
直接内存 (非运行时数据区的一部分)
1.8之前，有方法区(含有常量池)，1.8之后替换为元空间(直接内存)，并在堆中开辟了一块区域存放运行时常量池. 
原因：永久代是jvm指定大小，元空间受本机可用内存限制，减少溢出可能。



2.对象创建：类加载检查->分配内存（“指针碰撞” 和 “空闲列表” ）->初始化零值->设置对象头->执行init方法
内存分配的并发问题：虚拟机采用两种方式来保证线程安全：
CAS+失败重试： CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，
直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。
TLAB： 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，
当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配


3.对象内存布局：对象头、实例数据和对齐填充。
对象头：一部分用于存储对象自身的运行时数据（哈希码、GC 分代年龄、锁状态标志等等），另一部分是类型指针
实例数据：是对象真正存储的有效信息
对齐填充：不是必然存在的，也没有什么特别的含义，仅仅起占位作用(对象大小是8字节的整数倍)

4.对象的内存访问
句柄 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；
直接指针 直接指向内存区域的地址
使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，
而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。


5.垃圾回收器的种类
	串行垃圾回收器（Serial Garbage Collector）
	并行垃圾回收器（Parallel Garbage Collector）
	并发标记扫描垃圾回收器（CMS Garbage Collector）
	G1垃圾回收器（G1 Garbage Collector）

6.GC的底层实现原理
判断对象已死亡的方法：
1）引用计数法
就是通过一个计数器记录该对象被引用的次数，方法简单高效，但是解决不了循环引用的问题。
2）根搜索
通过选取一些根对象作为起始点，以有向图方式，开始向下搜索，如果一个对象到根对象不可达时，则说明此对象已经没有被引用，是可以被回收的。
可以作为根的对象有：栈中变量引用的对象，类静态属性引用的对象，常量引用的对象等。因为每个线程都有一个栈，所以我们需要选取多个根对象。	  
触发GC（Garbage Collector）的条件：
1)GC在优先级最低的线程中运行，一般在应用程序空闲即没有应用线程在运行时被调用。但下面的条件例外。
2)Java堆内存不足时，GC会被调用。当应用线程在运行，并在运行过程中创建新对象，若这时内存空间不足，JVM就会强制调用GC线程。
若GC一次之后仍不能满足内存分配，JVM会再进行两次GC，若仍无法满足要求，则JVM将报“out of memory”的错误，Java应用将停止。  
两个重要手动触发方法：
（1）System.gc()可以不管JVM使用的是哪一种垃圾回收的算法，都可以请求Java的垃圾回收。 会影响系统性能，不推荐使用。
（2）finalize（）Java提供了缺省机制来终止该对象心释放资源。使用特殊情况：
	1）由于在分配内存的时候可能采用了类似 C语言的做法，而非JAVA的通常new做法。
	2）又或者打开的文件资源，这些资源不属于垃圾回收器的回收范围。

7.对象引用：
  1）强引用，任何时候都不会被垃圾回收器回收，如果内存不足，宁愿抛出OutOfMemoryError。
  2）软引用，只有在内存将满的时候才会被垃圾回收器回收，如果还有可用内存，垃圾回收器不会回收。
  3）弱引用，只要垃圾回收器运行，就肯定会被回收，不管还有没有可用内存。
  4）虚引用，虚引用等于没有引用，任何时候都有可能被垃圾回收。

8.垃圾回收算法：
1.标记-清除收集器—>基于tracing算法。标记阶段的任务是标记出所有需要被回收的对象，
清除阶段就是回收被标记的对象所占用的空间。缺点：容易产生内存碎片
2.复制收集器—>基于Copying算法。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，
就将还存活着的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉，这样一来就不容易出现内存碎片的问题。
缺点：占用内存空间的大，当存活对象很多，那么Copying算法的效率将会大大降低。
3.标记-压缩收集器—>基于compacting算法。标记阶段的任务是标记出所有需要被回收的对象，
压缩阶段将存活对象都向一端移动，然后清理掉端边界以外的内存
4.分代收集器—>Generation算法。根据对象存活的生命周期将内存划分为若干个不同的区域。
一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），那么就可以根据不同代的特点采取最适合的收集算法。
老年代的特点是每次垃圾收集时只有少量对象需要被回收，一般使用的是Mark-Compact算法；
而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，采取Copying算法。

9.类加载过程
加载(双亲委派)->连接(验证->准备->解析)->初始化>使用->卸载(被GC)
类加载器：BootstrapClassLoader(启动类加载器) ExtensionClassLoader(扩展类加载器) AppClassLoader(应用程序类加载器)
双亲委派：首先会把该请求委派该父类加载器的 loadClass() 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 BootstrapClassLoader 中。
当父类加载器无法处理时，才由自己来处理。当父类加载器为null时，会使用启动类加载器 BootstrapClassLoader 作为父类加载器。
