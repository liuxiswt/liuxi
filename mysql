1.B+Tree的时间复杂度，数据结构？
二叉树：左子树的键值小于根的键值，右子树的键值大于根的键值。查找必须从根节点往下查找，最大时间复杂度为O(n).
平衡二叉树：任何节点的两个子树的高度最大差为1的二叉树，最小时间复杂度为OO(log2N，2为底数),近似于折半查找
**树的深度过大而造成磁盘I/O读写过于频繁，
Btree的最大时间复杂度在O(Log1.44n)
B-Tree: 有序数组(二元组[key, data]，key是主键，data是一行记录中除主键外的数据.)+平衡多叉树；
InnoDB存储引擎中有页（Page）的概念，磁盘管理的最小单位。InnoDB存储引擎中默认每个页的大小为16KB，
可通过参数innodb_page_size将页的大小设置为4K、8K、16K，查看页的大小：mysql> show variables like 'innodb_page_size';
一棵m阶的B-Tree有如下特性： 
1. 每个节点最多有m个孩子。 
2. 除了根节点和叶子节点外，其它每个节点至少有Ceil(m/2)个孩子。 
3. 若根节点不是叶子节点，则至少有2个孩子 
4. 所有叶子节点都在同一层，且不包含其它关键字信息 
5. 每个非终端节点包含n个关键字信息（P0,P1,…Pn, k1,…kn） 
6. 关键字的个数n满足：ceil(m/2)-1 <= n <= m-1 
7. ki(i=1,…n)为关键字，且关键字升序排序。 
8. Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)

B+Tree:有序数组链表+平衡多叉树
B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，
而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。
数据库中的B+Tree索引可以分为聚集索引（clustered index）和辅助索引（secondary index）。
聚集索引的B+Tree中的叶子节点存放的是整张表的行记录数据。
辅助索引与聚集索引的区别在于辅助索引的叶子节点并不包含行记录的全部数据，而是存储相应行数据的聚集索引键，即主键。
当通过辅助索引来查询数据时，InnoDB存储引擎会遍历辅助索引找到主键，然后再通过主键在聚集索引中找到完整的行记录数据。

B*Tree:一棵丰满的B+-tree
在B+-tree的非根和非叶子结点再增加指向兄弟的指针；B*-tree定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3（代替B+树的1/2）


2.mysql的四种引擎，原理？
3.redis相关，架构，模式？
4.TCP/UDP区别联系？
5.线程和进程的区别，内存分配，工作模式？
6.设计一个简单socket交互？
