1.B+Tree的时间复杂度，数据结构？
二叉树：左子树的键值小于根的键值，右子树的键值大于根的键值。查找必须从根节点往下查找，最大时间复杂度为O(n).
平衡二叉树：任何节点的两个子树的高度最大差为1的二叉树，最小时间复杂度为OO(log2N，2为底数),近似于折半查找
**树的深度过大而造成磁盘I/O读写过于频繁，
Btree的最大时间复杂度在O(Log1.44n)
B-Tree: 有序数组(二元组[key, data]，key是主键，data是一行记录中除主键外的数据.)+平衡多叉树；
InnoDB存储引擎中有页（Page）的概念，磁盘管理的最小单位。InnoDB存储引擎中默认每个页的大小为16KB，
可通过参数innodb_page_size将页的大小设置为4K、8K、16K，查看页的大小：mysql> show variables like 'innodb_page_size';
一棵m阶的B-Tree有如下特性： 
1. 每个节点最多有m个孩子。 
2. 除了根节点和叶子节点外，其它每个节点至少有Ceil(m/2)个孩子。 
3. 若根节点不是叶子节点，则至少有2个孩子 
4. 所有叶子节点都在同一层，且不包含其它关键字信息 
5. 每个非终端节点包含n个关键字信息（P0,P1,…Pn, k1,…kn） 
6. 关键字的个数n满足：ceil(m/2)-1 <= n <= m-1 
7. ki(i=1,…n)为关键字，且关键字升序排序。 
8. Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)

B+Tree:有序数组链表+平衡多叉树
B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，
而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。
数据库中的B+Tree索引可以分为聚集索引（clustered index）和辅助索引（secondary index）。
聚集索引的B+Tree中的叶子节点存放的是整张表的行记录数据。
辅助索引与聚集索引的区别在于辅助索引的叶子节点并不包含行记录的全部数据，而是存储相应行数据的聚集索引键，即主键。
当通过辅助索引来查询数据时，InnoDB存储引擎会遍历辅助索引找到主键，然后再通过主键在聚集索引中找到完整的行记录数据。

B*Tree:一棵丰满的B+-tree
在B+-tree的非根和非叶子结点再增加指向兄弟的指针；B*-tree定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3（代替B+树的1/2）


2.mysql的四种引擎，原理?
(1)InnoDB引擎：
支持自动增长列，支持外键约束，具备提交、回滚和崩溃恢复能力的事务安全。适用在经常更新的表，多重并发的更新请求。
(2)MyISAM引擎：不支持事务、也不支持外键，优势是访问速度快。支持3种不同的存储格式：静态表；动态表；压缩表。
引擎在创建表的时候，会创建三个文件，一个是.frm文件用于存储表的定义，一个是.MYD文件用于存储表的数据，另一个是.MYI文件，存储的是索引。
操作系统对大文件的操作是比较慢的，这样将表分为三个文件，那么.MYD这个文件单独来存放数据自然可以优化数据库的查询等操作。
有索引管理和字段管理。MyISAM还使用一种表格锁定的机制，来优化多个并发的读写操作，其代价是你需要经常运行OPTIMIZE TABLE命令，
来恢复被更新机制所浪费的空间。存储了表的行数。查询总数时不需要进行全表扫描。
缺点：就是不能在表损坏后恢复数据。（是不能主动恢复，可以做主动备份）
适用于做很多count的计算的。如一些日志，调查的业务表。插入修改不频繁，查询非常频繁的。
ISAM索引方法–索引顺序存取方法：
优点：定义明确且历经时间考验的数据表格管理方法，它在设计之时就考虑到 数据库被查询的次数要远大于更新的次数。
缺点：也不能够容错。如果你的硬盘崩溃了，那么数据文件就无法恢复了。如果你正在把ISAM用在关键任务应用程序里，
那就必须经常备份你所有的实 时数据，通过其复制特性，MYSQL能够支持这样的备份应用程序。
(3)Memory引擎：
内存中的内容来创建表。每个MEMORY表只实际对应一个磁盘文件,默认使用HASH索引。
Hash索引缺点： 那么不精确查找呢，也很明显，因为hash算法是基于等值计算的，所以对于“like”等范围查找hash索引无效，不支持；
是一旦服务关闭，表中的数据就会丢失掉。 HEAP允许只驻留在内存里的临时表格。Memory同时支持散列索引和B树索引，B树索引可以使用部分查询和通配查询，
也可以使用<,>和>=等操作符方便数据挖掘，散列索引相等的比较快但是对于范围的比较慢很多。
(4)MERGE引擎：
Merge存储引擎是一组MyISAM表的组合，这些MyISAM表必须结构完全相同，merge表本身并没有数据，对merge类型的表可以进行查询，更新，删除操作，
这些操作实际上是对内部的MyISAM表进行的。


3.mysql中的utf8 和utf8mb4 及排序？
utf8最长使用3个字节,目的是为了节省空间。 5.5.3V之后增加了 utf8mb4 字符编码，mb4即 most bytes 4,使用4个字节来表示完整的UTF-8。
utf8mb4_bin： 将字符串每个字符用二进制数据编译存储，区分大小写，而且可以存二进制的内容。
utf8mb4_general_ci：不区分大小写，是一个遗留的校对规则，不支持扩展，它仅能够在字符之间进行逐个比较，没有实现Unicode排序规则，
在遇到某些特殊语言或者字符集，排序结果可能不一致。但是，在绝大多数情况下，这些特殊字符的顺序并不需要那么精确。（比较排序快，性能高)
utf8mb4_unicode_ci：是基于标准的Unicode来排序和比较，能够在各种语言之间精确排序，Unicode排序规则为了能够处理特殊字符的情况，
实现了略微复杂的排序算法。（精确度高）
collate规则：
utf8mb4_bin 大小写敏感
utf8mb4_general_cs 大小写敏感
*_bin: 表示的是binary case sensitive collation，也就是说是区分大小写的
*_cs: case sensitive collation，区分大小写
*_ci: case insensitive collation，不区分大小写

3.redis相关，架构，模式？
(1)主从模式:备份数据 + 负载均衡 
(2)哨兵模式sentinel：在主从模式上，当master节点挂了以后，slave节点不能主动选举一个master节点出来，恢复的master会作为slave节点。
一个sentinel或sentinel集群可以管理多个主从Redis
(3)集群模式cluster：将Redis的数据根据一定的规则分配到多台机器，数据量过大时，可以新增机器进行扩容.可以实现主从和master重选功能.


4.TCP/UDP区别联系？
(1)TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接
(2)TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付
(3)TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的
UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）
(4)每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信
(5)TCP首部开销20字节;UDP的首部开销小，只有8个字节
(6)TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道
UDP应用场景：（视频，语音等方面）
  1.面向数据报方式
  2.网络数据大多为短消息 
  3.拥有大量Client
  4.对数据安全性无特殊要求
  5.网络负担非常重，但对响应速度要求高

5.线程和进程的区别，内存分配，工作模式？
进程是一个计算机程序的实例,由一个或者多个线程组成.
线程CPU调度和分配时间的基本单位。
联系：一个进程可以包括多个线程, 一个线程只能属于一个进程.
区别：进程之间是不共享地址空间的, 而线程是共享着进程的地址空间.
时间片机制：为每个线程分配时间额度，如果当前线程的时间额度用完了，就会被强制停止（不考虑优先级等机制），切换其他线程执行；
抢占先式多线程：操作系统不必等待一个线程,它可主动将处理器让给其它线程。
在这种方式下,当一个线程已运行了配额的时间后，或出现抢先情况时，操作系统将中断该线程。线程转让CPU处理时间是被迫的。
占先式多任务可以防止线程独占CPU,允许其它线程公平地分享CPU执行时间，同时也节省了时间。

6.设计一个简单socket交互？
