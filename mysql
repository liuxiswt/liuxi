1.B+Tree的时间复杂度，数据结构？
二叉树：左子树的键值小于根的键值，右子树的键值大于根的键值。查找必须从根节点往下查找，最大时间复杂度为O(n).
平衡二叉树：任何节点的两个子树的高度最大差为1的二叉树，最小时间复杂度为OO(log2N，2为底数),近似于折半查找
**树的深度过大而造成磁盘I/O读写过于频繁，
Btree的最大时间复杂度在O(Log1.44n)
B-Tree: 有序数组(二元组[key, data]，key是主键，data是一行记录中除主键外的数据.)+平衡多叉树；
InnoDB存储引擎中有页（Page）的概念，磁盘管理的最小单位。InnoDB存储引擎中默认每个页的大小为16KB，
可通过参数innodb_page_size将页的大小设置为4K、8K、16K，查看页的大小：mysql> show variables like 'innodb_page_size';
一棵m阶的B-Tree有如下特性： 
1. 每个节点最多有m个孩子。 
2. 除了根节点和叶子节点外，其它每个节点至少有Ceil(m/2)个孩子。 
3. 若根节点不是叶子节点，则至少有2个孩子 
4. 所有叶子节点都在同一层，且不包含其它关键字信息 
5. 每个非终端节点包含n个关键字信息（P0,P1,…Pn, k1,…kn） 
6. 关键字的个数n满足：ceil(m/2)-1 <= n <= m-1 
7. ki(i=1,…n)为关键字，且关键字升序排序。 
8. Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)

B+Tree:有序数组链表+平衡多叉树
B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，
而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。
数据库中的B+Tree索引可以分为聚集索引（clustered index）和辅助索引（secondary index）。
聚集索引的B+Tree中的叶子节点存放的是整张表的行记录数据。
辅助索引与聚集索引的区别在于辅助索引的叶子节点并不包含行记录的全部数据，而是存储相应行数据的聚集索引键，即主键。
当通过辅助索引来查询数据时，InnoDB存储引擎会遍历辅助索引找到主键，然后再通过主键在聚集索引中找到完整的行记录数据。
MyISAM实现
B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，
然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。
InnoDB实现
其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，
树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。
这被称为“聚簇索引（或聚集索引）”，而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。
在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，在走一遍主索引。 
因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。

B*Tree:一棵丰满的B+-tree
在B+-tree的非根和非叶子结点再增加指向兄弟的指针；B*-tree定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3（代替B+树的1/2）


2.mysql的四种引擎，原理?
(1)InnoDB引擎：
支持自动增长列，支持外键约束，具备提交、回滚和崩溃恢复能力的事务安全。适用在经常更新的表，多重并发的更新请求。
(2)MyISAM引擎：不支持事务、也不支持外键，优势是访问速度快。支持3种不同的存储格式：静态表；动态表；压缩表。
引擎在创建表的时候，会创建三个文件，一个是.frm文件用于存储表的定义，一个是.MYD文件用于存储表的数据，另一个是.MYI文件，存储的是索引。
操作系统对大文件的操作是比较慢的，这样将表分为三个文件，那么.MYD这个文件单独来存放数据自然可以优化数据库的查询等操作。
有索引管理和字段管理。MyISAM还使用一种表格锁定的机制，来优化多个并发的读写操作，其代价是你需要经常运行OPTIMIZE TABLE命令，
来恢复被更新机制所浪费的空间。存储了表的行数。查询总数时不需要进行全表扫描。
缺点：就是不能在表损坏后恢复数据。（是不能主动恢复，可以做主动备份）
适用于做很多count的计算的。如一些日志，调查的业务表。插入修改不频繁，查询非常频繁的。
ISAM索引方法–索引顺序存取方法：
优点：定义明确且历经时间考验的数据表格管理方法，它在设计之时就考虑到 数据库被查询的次数要远大于更新的次数。
缺点：也不能够容错。如果你的硬盘崩溃了，那么数据文件就无法恢复了。如果你正在把ISAM用在关键任务应用程序里，
那就必须经常备份你所有的实 时数据，通过其复制特性，MYSQL能够支持这样的备份应用程序。
(3)Memory引擎：
内存中的内容来创建表。每个MEMORY表只实际对应一个磁盘文件,默认使用HASH索引。
Hash索引缺点： 那么不精确查找呢，也很明显，因为hash算法是基于等值计算的，所以对于“like”等范围查找hash索引无效，不支持；
是一旦服务关闭，表中的数据就会丢失掉。 HEAP允许只驻留在内存里的临时表格。Memory同时支持散列索引和B树索引，B树索引可以使用部分查询和通配查询，
也可以使用<,>和>=等操作符方便数据挖掘，散列索引相等的比较快但是对于范围的比较慢很多。
(4)MERGE引擎：
Merge存储引擎是一组MyISAM表的组合，这些MyISAM表必须结构完全相同，merge表本身并没有数据，对merge类型的表可以进行查询，更新，删除操作，
这些操作实际上是对内部的MyISAM表进行的。


3.mysql中的utf8 和utf8mb4 及排序？
utf8最长使用3个字节,目的是为了节省空间。 5.5.3V之后增加了 utf8mb4 字符编码，mb4即 most bytes 4,使用4个字节来表示完整的UTF-8。
utf8mb4_bin： 将字符串每个字符用二进制数据编译存储，区分大小写，而且可以存二进制的内容。
utf8mb4_general_ci：不区分大小写，是一个遗留的校对规则，不支持扩展，它仅能够在字符之间进行逐个比较，没有实现Unicode排序规则，
在遇到某些特殊语言或者字符集，排序结果可能不一致。但是，在绝大多数情况下，这些特殊字符的顺序并不需要那么精确。（比较排序快，性能高)
utf8mb4_unicode_ci：是基于标准的Unicode来排序和比较，能够在各种语言之间精确排序，Unicode排序规则为了能够处理特殊字符的情况，
实现了略微复杂的排序算法。（精确度高）
collate规则：
utf8mb4_bin 大小写敏感
utf8mb4_general_cs 大小写敏感
*_bin: 表示的是binary case sensitive collation，也就是说是区分大小写的
*_cs: case sensitive collation，区分大小写
*_ci: case insensitive collation，不区分大小写


4.索引：普通索引、全文索引、主键索引、唯一索引、组合索引
优势：
(1)过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
(2)可以大大加快 数据的检索速度（大大减少的检索的数据量）, 这也是创建索引的最主要的原因。
(3)帮助服务器避免排序和临时表。
(4)将随机IO变为顺序IO
(5)可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。
使用规则：
(1)最左前缀匹配原则：MySQL会一直向右匹配直到遇到范围查询（>,<,BETWEEN,LIKE）就停止匹配；
(2)区分度高的列作为索引；
(3)索引列不能参与计算；
(4)尽可能的扩展索引，不要新建立索引(维护索引占物理和数据空间)；
(5)覆盖索引(推荐)：
如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。
我们知道InnoDB存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。
这样就会比较慢覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！

5.mysql执行sql流程：
MySQL 主要分为 Server 层和引擎层，Server 层主要包括连接器、查询缓存、分析器、优化器、执行器，同时还有一个日志模块（binlog），
这个日志模块所有执行引擎都可以共用,redolog 只有 InnoDB 有(支持事务)。
引擎层是插件式的，目前主要包括，MyISAM,InnoDB,Memory 等。
查询语句的执行流程如下：权限校验（如果命中缓存）---》查询缓存---》分析器---》优化器---》权限校验---》执行器---》引擎
更新语句执行流程如下：分析器----》权限校验----》执行器---》引擎---redo log(prepare 状态---》binlog---》redo log(commit状态)

3.redis相关，架构，模式？
(1)主从模式:备份数据 + 负载均衡 
(2)哨兵模式sentinel：在主从模式上，当master节点挂了以后，slave节点不能主动选举一个master节点出来，恢复的master会作为slave节点。
一个sentinel或sentinel集群可以管理多个主从Redis
(3)集群模式cluster：将Redis的数据根据一定的规则分配到多台机器，数据量过大时，可以新增机器进行扩容.可以实现主从和master重选功能.


6.设计一个简单socket交互？
