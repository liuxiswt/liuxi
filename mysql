1.B+Tree的时间复杂度，数据结构？
二叉树：左子树的键值小于根的键值，右子树的键值大于根的键值。查找必须从根节点往下查找，最大时间复杂度为O(n).
平衡二叉树：任何节点的两个子树的高度最大差为1的二叉树，最小时间复杂度为OO(log2N，2为底数),近似于折半查找
**树的深度过大而造成磁盘I/O读写过于频繁，
Btree的最大时间复杂度在O(Log1.44n)
B-Tree: 有序数组(二元组[key, data]，key是主键，data是一行记录中除主键外的数据.)+平衡多叉树；
InnoDB存储引擎中有页（Page）的概念，磁盘管理的最小单位。InnoDB存储引擎中默认每个页的大小为16KB，
可通过参数innodb_page_size将页的大小设置为4K、8K、16K，查看页的大小：mysql> show variables like 'innodb_page_size';
一棵m阶的B-Tree有如下特性： 
1. 每个节点最多有m个孩子。 
2. 除了根节点和叶子节点外，其它每个节点至少有Ceil(m/2)个孩子。 
3. 若根节点不是叶子节点，则至少有2个孩子 
4. 所有叶子节点都在同一层，且不包含其它关键字信息 
5. 每个非终端节点包含n个关键字信息（P0,P1,…Pn, k1,…kn） 
6. 关键字的个数n满足：ceil(m/2)-1 <= n <= m-1 
7. ki(i=1,…n)为关键字，且关键字升序排序。 
8. Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)

B+Tree:有序数组链表+平衡多叉树
B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，
而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。
数据库中的B+Tree索引可以分为聚集索引（clustered index）和辅助索引（secondary index）。
聚集索引的B+Tree中的叶子节点存放的是整张表的行记录数据。
辅助索引与聚集索引的区别在于辅助索引的叶子节点并不包含行记录的全部数据，而是存储相应行数据的聚集索引键，即主键。
当通过辅助索引来查询数据时，InnoDB存储引擎会遍历辅助索引找到主键，然后再通过主键在聚集索引中找到完整的行记录数据。

B*Tree:一棵丰满的B+-tree
在B+-tree的非根和非叶子结点再增加指向兄弟的指针；B*-tree定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3（代替B+树的1/2）


2.mysql的四种引擎，原理？

3.mysql中的utf8 和utf8mb4 及排序？
utf8最长使用3个字节,目的是为了节省空间。 5.5.3V之后增加了 utf8mb4 字符编码，mb4即 most bytes 4,使用4个字节来表示完整的UTF-8。
utf8mb4_bin： 将字符串每个字符用二进制数据编译存储，区分大小写，而且可以存二进制的内容。
utf8mb4_general_ci：不区分大小写，是一个遗留的校对规则，不支持扩展，它仅能够在字符之间进行逐个比较，没有实现Unicode排序规则，
在遇到某些特殊语言或者字符集，排序结果可能不一致。但是，在绝大多数情况下，这些特殊字符的顺序并不需要那么精确。（比较排序快，性能高)
utf8mb4_unicode_ci：是基于标准的Unicode来排序和比较，能够在各种语言之间精确排序，Unicode排序规则为了能够处理特殊字符的情况，
实现了略微复杂的排序算法。（精确度高）
collate规则：
utf8mb4_bin 大小写敏感
utf8mb4_general_cs 大小写敏感
*_bin: 表示的是binary case sensitive collation，也就是说是区分大小写的
*_cs: case sensitive collation，区分大小写
*_ci: case insensitive collation，不区分大小写

3.redis相关，架构，模式？
4.TCP/UDP区别联系？
5.线程和进程的区别，内存分配，工作模式？
6.设计一个简单socket交互？
